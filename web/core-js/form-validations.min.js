/**
 * ViraXpress - https://www.viraxpress.com
 *
 * LICENSE AGREEMENT
 *
 * This file is part of the ViraXpress package and is licensed under the ViraXpress license agreement.
 * You can view the full license at:
 * https://www.viraxpress.com/license
 *
 * By utilizing this file, you agree to comply with the terms outlined in the ViraXpress license.
 *
 * DISCLAIMER
 *
 * Modifications to this file are discouraged to ensure seamless upgrades and compatibility with future releases.
 *
 * @author      ViraXpress
 * @copyright   Â© 2024 ViraXpress (https://www.viraxpress.com/)
 * @license     https://www.viraxpress.com/license
 */

window.formValidateData = window.formValidateData || {};
(function(formValidateData) {
    const validationRules = {};
    const elementAttributes = ['minlength', 'maxlength', 'min','required','max', 'pattern','step'];
    const emailAttribute = ['email'];
    const novalidateForm = (formElement) => {
        formElement.tagName === 'FORM' ? formElement.setAttribute('novalidate', '') : null;
    };
    function mergeObjects(obj1, obj2) {
        for (let key in obj2) {
            if (obj1.hasOwnProperty(key)) {
                obj1[key] = obj2[key];
            } else {
                obj1[key] = obj2[key];
            }
        }
        return obj1;
    }
    function getValidateElements(element) {
        const validateElements = {};

        elementAttributes.forEach(attribute => {
            if (element.hasAttribute(attribute)) {
                validateElements[attribute] = element.getAttribute(attribute);
            }
        });

        if (emailAttribute.includes(element.type)) {
            validateElements[element.type] = true;
        }

        const validateData = element.dataset.validate;
        if (validateData) {
            try {
                const parsedData = JSON.parse(validateData);
                Object.assign(validateElements, parsedData);
            } catch (error) {
                console.error('Error parsing the data-validate attribute:', element, 'Error details:', error);
            }
        }

        return validateElements;
    }
    function formDataValidation(formElement, actionUrl='') {
        novalidateForm(formElement);

        return {
            fields: {},
            showPassword: false,
            passwordValidated:true,
            initLoad : {},
            customerDetails : {},
            message : 'Required field.',
            displayLoading: false,
            displayAddressFields: false,
            loginEmail:'',
            
            init() {
                this.fields = this.collectFields(formElement);
                this.initLoad = { ...this.fields };
            },
            collectFields(formElement) {
                const elements = Array.from(formElement.elements);
                return elements.reduce((acc, element) => {
                    if (this.shouldValidate(element)) {
                        const rules = getValidateElements(element);
                        if (Object.keys(rules).length > 0) {
                            acc[element.name] = acc[element.name] || { element, rules: {} };
                            Object.assign(acc[element.name].rules, rules);
                        }
                    }
                    return acc;
                }, {});
            },
            shouldValidate(element) {
                const isButton = element.tagName === 'BUTTON';
                const isHidden = element.type === 'hidden';
                const isSubmit = element.tagName === 'INPUT' && element.type === 'submit';
                const isDisabled = element.disabled;
                const shouldValidate = element.willValidate;
                
                return !isButton && !isSubmit && (shouldValidate || isHidden) && !isDisabled;
            },
            hasAnyValue(obj) {
                const attributes = elementAttributes.filter(item => item !== 'required');
                const hasValue = Object.keys(obj).some(key => obj[key] && attributes.includes(key));
                return hasValue;
            },
            arrangeField(element) {
                const shouldSkip = ['BUTTON', 'submit'].includes(element.type) || element.disabled || (!element.willValidate && element.type !== 'hidden');
                
                if (shouldSkip) {
                    console.error('Element does not meet validation criteria', element);
                    return;
                }
                
                const rules = getValidateElements(element);
                
                if (Object.keys(rules).length === 0) {
                    return;
                }
                
                if (!this.fields[element.name]) {
                    this.fields[element.name] = { element, rules };
                } else {
                    this.fields[element.name].rules = { ...this.fields[element.name].rules, ...rules };
                }
            },
            onSubmit(event) {
                const formElement = event.target;
                
                if (formElement.tagName !== 'FORM') {
                    return;
                }
                event.preventDefault();
                if (this.validateFields()) {
                    this.displayLoading = true;
                    this.ajaxSubmit(event); 
                }
            },
            onChange(event) {
                const fieldName = event.target.name;

                // Ensure fields are initialized
                if (!Object.keys(this.fields).length) {
                    this.initializeFields(formElement);
                }

                // Arrange the target field if not already in fields
                if (!this.fields[fieldName]) {
                    this.arrangeField(event.target);
                }

                const field = this.fields[fieldName];

                if (!field || !field.rules) {
                    return;
                }
                
                const ruleCondition = this.attributeValidationEvent(field.rules, field);

                // Render required message if conditions are met
                if (ruleCondition) {
                    this.requiredMessageRender(field, this.message);
                }

                // Get rule message if no value in rules
                if (!this.hasAnyValue(field.rules)) {
                    this.getRuleMessage(field);
                }

                // Special handling for specific fields
                this.handleSpecificFields(field, fieldName);
            },

            initializeFields(formElement) {
                this.fields = {};
                const elements = Array.from(formElement.elements);

                elements.forEach(element => {
                    if (this.shouldArrangeField(element)) {
                        this.arrangeField(element);
                    }
                });
            },

            shouldArrangeField(element) {
                const isButton = element.tagName === 'BUTTON';
                const isHidden = element.type === 'hidden';
                const isSubmit = element.tagName === 'INPUT' && element.type === 'submit';
                const isDisabled = element.disabled;
                const shouldValidate = element.willValidate;

                return !isButton && !isSubmit && (shouldValidate || isHidden) && !isDisabled;
            },

            handleSpecificFields(field, fieldName) {
                if (fieldName === 'country_id') {
                    const postCode = this.fields['postcode'];
                    if (postCode && postCode.element.value) {
                        this.getRuleMessage(postCode);
                    }
                }

                if (document.getElementById('accountcreate') && fieldName === 'email') {
                    this.validateEmail(field);
                }
                if (fieldName === 'email' || field.element.type === 'email') {
                    this.requiredMessageRender(field, this.message);
                }

                if (fieldName === 'password') {
                    this.requiredMessageRender(field, this.message);
                    this.validatePassword(field);
                }

                if (fieldName === 'password_confirmation') {
                    this.requiredMessageRender(field, this.message);
                    this.validateConfirmPassword(field);
                }
            },
            focusOnFormField(fields) {
                const emptyField = fields.find(field => !field.element.value);
                if (emptyField) {
                    emptyField.element.focus();
                }
            },
            attributeValidationEvent(rules, field) {
                if (this.hasAnyValue(field.rules)) {
                    return this.attributeValidation(field.element.value, rules, field);
                }
                return true;
            },
            validateFields() {
                const formElements = Array.from(formElement.elements);
                const visibleFields = this.getVisibleFields(formElements);

                if (Object.keys(this.fields).length !== visibleFields.length) {
                    visibleFields.forEach(element => this.arrangeField(element));
                }

                const fields = this.initLoad ? Object.values(mergeObjects(this.initLoad, this.fields)) : Object.values(this.fields);

                this.focusOnFormField(fields);

                const validationResults = this.validateAllFields(fields);
                return this.determineFormSubmission(validationResults);
            },

            getVisibleFields(formElements) {
                return formElements.filter(element => {
                    const isButton = element.tagName === 'BUTTON';
                    const isSubmit = element.tagName === 'INPUT' && element.type === 'submit';
                    const isHidden = element.type === 'hidden';
                    const isDisabled = element.disabled;
                    const shouldValidate = element.willValidate;

                    return !isButton && !isSubmit && (shouldValidate || isHidden) && !isDisabled;
                });
            },

            validateAllFields(fields) {
                let allFieldsNotEmpty = true;
                const selectedFields = [];
                let validatedPassword = true;
                let validateConfirmPassword = true;
                let emailValidate = false;
                let dateOfBirth = false;
                let isRecaptchaVerify = false;

                const validationFlags = {
                    isPassword: false,
                    isEmail: false,
                    isRecaptcha: false,
                    isAttribute: false,
                    isConfirmPassword: false,
                    isDOB: false,
                    validatedAttributeArray: []
                };

                fields.forEach(field => {
                    if (this.hasAnyValue(field.rules)) {
                        validationFlags.isAttribute = true;
                        const attributeValidation = this.attributeValidationEvent(field.rules, field);
                        if (!field.element.value && this.hasAnyValue(field.rules)) {
                            allFieldsNotEmpty = this.requiredMessageRender(field, this.message);
                        }
                        validationFlags.validatedAttributeArray.push(attributeValidation);
                    } else {
                        allFieldsNotEmpty = this.requiredMessageRender(field, this.message);
                    }

                    if (field.element) {
                        switch (field.element.name) {
                            case 'password':
                                validationFlags.isPassword = true;
                                validatedPassword = this.validatePassword(field);
                                break;
                            case 'password_confirmation':
                                validationFlags.isConfirmPassword = true;
                                validateConfirmPassword = this.validateConfirmPassword(field);
                                break;
                            case 'email':
                                validationFlags.isEmail = true;
                                emailValidate = this.validateEmail(field);
                                break;
                           case 'login[username]':
                                validationFlags.isEmail = true;
                                emailValidate = this.validateEmail(field);
                                break;
                            case 'dob':
                                validationFlags.isDOB = true;
                                dateOfBirth = this.validateDob(field);
                                break;
                        }
                         if(field.element.name == 'email' || field.element.type == 'email') {
                            if(!field.element.value) {
                                this.requiredMessageRender(field,this.message);
                            }
                        }
                        if (field.element.className === 'required-captcha checkbox') {
                            validationFlags.isRecaptcha = true;
                            if (field.element.checked) {
                                allFieldsNotEmpty = true;
                                isRecaptchaVerify = true;
                                document.getElementById('recaptcha-validate--error').remove();
                            }
                        }

                        selectedFields.push(allFieldsNotEmpty);
                    }
                });

                return {
                    allFieldsNotEmpty,
                    selectedFields,
                    validatedPassword,
                    validateConfirmPassword,
                    emailValidate,
                    dateOfBirth,
                    isRecaptchaVerify,
                    validationFlags
                };
            },

            determineFormSubmission({
                allFieldsNotEmpty,
                selectedFields,
                validatedPassword,
                validateConfirmPassword,
                emailValidate,
                dateOfBirth,
                isRecaptchaVerify,
                validationFlags
            }) {
                let isSubmitForm = false;

                const validateAllFields = selectedFields.every(value => value === true);
                const passwordValidated = validatedPassword && validateConfirmPassword;

                if (validationFlags.isRecaptcha) {
                    isSubmitForm = isRecaptchaVerify;
                }
                if (validationFlags.isDOB) {
                    allFieldsNotEmpty = dateOfBirth;
                }
                if (!validateAllFields) {
                    allFieldsNotEmpty = false;
                }
                if (allFieldsNotEmpty) {
                    isSubmitForm = true;
                }
                if (event.target.id === 'login-form') {
                    validationFlags.isPassword = true;
                }
                if (validationFlags.isPassword && validationFlags.isEmail) {
                    isSubmitForm = allFieldsNotEmpty && passwordValidated && emailValidate;
                } else {
                    isSubmitForm = allFieldsNotEmpty && passwordValidated;
                }
                if (!validationFlags.isPassword && validationFlags.isEmail) {
                    isSubmitForm = allFieldsNotEmpty && emailValidate;
                }
                if (event.target.id === 'form-validate') {
                    isSubmitForm = allFieldsNotEmpty && validationFlags.isEmail && emailValidate;
                }
                if (validationFlags.isAttribute) {
                    const allAttributeVerified = validationFlags.validatedAttributeArray.every(value => value === true);
                    isSubmitForm = allFieldsNotEmpty && allAttributeVerified;
                }

                return isSubmitForm;
            },
            attributeValidation(fieldValue, rules, field) {
                let attributeValidate = true;
                let validateMessage = null;

                if (fieldValue) {
                    const validationResult = this.runValidations(fieldValue, rules);

                    attributeValidate = validationResult.isValid;
                    validateMessage = validationResult.message;

                    this.renderMessage(field, validateMessage, false);
                }

                this.getRuleMessage(field);
                return attributeValidate;
            },

            runValidations(fieldValue, rules) {
                if (fieldValue.length < rules.minlength) {
                    return { isValid: false, message: `Field length should be at least ${rules.minlength}` };
                }

                if (fieldValue.length > rules.maxlength) {
                    return { isValid: false, message: `Field length should be at most ${rules.maxlength}` };
                }

                const numericValue = parseFloat(fieldValue);
                if (numericValue < rules.min) {
                    return { isValid: false, message: `Field value should be at least ${rules.min}` };
                }

                if (numericValue > rules.max) {
                    return { isValid: false, message: `Field value should be at most ${rules.max}` };
                }

                if (!this.isValidStep(numericValue, rules.step)) {
                    return { isValid: false, message: `Field value should be a multiple of ${rules.step}` };
                }

                if (rules.pattern && !this.matchesPattern(fieldValue, rules.pattern)) {
                    return { isValid: false, message: `Field value should match the pattern ${rules.pattern}` };
                }

                return { isValid: true, message: null };
            },

            isValidStep(value, step) {
                return Math.abs(value - Math.round(value / step) * step) <= Number.EPSILON;
            },

            matchesPattern(value, pattern) {
                const regex = new RegExp(`^${pattern}$`);
                return regex.test(value);
            },
            validateDob(field) {
                const selectedDate = new Date(field.element.value);
                const currentDate = new Date();
                const isValidDate = this.isDateValid(selectedDate, currentDate);

                if (!isValidDate) {
                    const validateMessage = 'The Date of Birth should not be greater than today.';
                    this.renderMessage(field, validateMessage, false);
                    field.element.value = "";
                }

                return isValidDate;
            },

            isDateValid(selectedDate, currentDate) {
                // Adjust current date to "today" by subtracting one day
                const today = new Date(currentDate.setDate(currentDate.getDate() - 1));
                return selectedDate <= today;
            },
            validateEmail(field) {
                const email = field.element.value;
                const emailRegex = this.getEmailRegex();
                let isEmailValid = this.checkEmailFormat(email, emailRegex);
                if (!isEmailValid) {
                    const validationMessage = 'Please enter a valid email address.';
                    this.renderMessage(field, validationMessage, false);
                } else {
                    this.renderMessage(field, '', true);
                }

                return isEmailValid;
            },

            getEmailRegex() {
                return /^([a-z0-9,!\#\$%&'\*\+\/=\?\^_`\{\|\}~-]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z0-9,!\#\$%&'\*\+\/=\?\^_`\{\|\}~-]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*@([a-z0-9-]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z0-9-]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*\.(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]){2,})$/i;
            },

            checkEmailFormat(email, regex) {
                return regex.test(email);
            },
            validatePassword(field) {
                if (!field.element.value) {
                    return true;
                }

                const password = field.element.value;
                const validationResults = this.getPasswordValidationResults(password);

                if (!validationResults.isValid) {
                    this.renderMessage(field, validationResults.message, false);
                } else {
                    this.renderMessage(field, '', true);
                }

                return validationResults.isValid;
            },

            getPasswordValidationResults(password) {
                const isLengthValid = this.isLengthValid(password);
                const conditionsMet = this.checkCharacterClasses(password);

                if (!isLengthValid) {
                    return {
                        isValid: false,
                        message: 'Minimum length of this field must be equal or greater than 8 symbols. Leading and trailing spaces will be ignored.'
                    };
                }

                if (!conditionsMet) {
                    return {
                        isValid: false,
                        message: 'Minimum of different classes of characters in password is 3. Classes of characters: Lower Case, Upper Case, Digits, Special Characters.'
                    };
                }

                return {
                    isValid: true,
                    message: ''
                };
            },

            isLengthValid(password) {
                return password.length >= 8;
            },

            checkCharacterClasses(password) {
                const hasUpperCase = /[A-Z]/.test(password);
                const hasLowerCase = /[a-z]/.test(password);
                const hasDigit = /\d/.test(password);
                const hasSpecialChar = /[^A-Za-z0-9]/.test(password);

                return [hasUpperCase, hasLowerCase, hasDigit, hasSpecialChar].filter(Boolean).length >= 3;
            },
           validateConfirmPassword(field) {
                if (!field.element.value) {
                    return true;
                }

                const confirmPassword = field.element.value;
                const password = this.getPasswordValue();
                const isPasswordValid = this.arePasswordsMatching(confirmPassword, password);

                this.displayValidationMessage(field, isPasswordValid);

                return isPasswordValid;
            },

            getPasswordValue() {
                const passwordField = document.getElementById('password');
                return passwordField ? passwordField.value : '';
            },

            arePasswordsMatching(confirmPassword, password) {
                return confirmPassword === password;
            },

            displayValidationMessage(field, isPasswordValid) {
                const validationMessage = isPasswordValid ? '' : 'Passwords do not match.';
                this.renderMessage(field, validationMessage, isPasswordValid);
            },
            getRuleMessage(field) {
                const fieldValue = document.getElementById(field.element.id).value;
                const options = field.rules || {};
                const validationResult = this.validateFieldWithRules(field, fieldValue, options);

                this.insertRuleMessage(field, validationResult.message, validationResult.isValid);
                return validationResult.isValid;
            },
            validateFieldWithRules(field, fieldValue, options) {
                if (!formValidateData.formDataValidation.rules[field.element.name] || !fieldValue) {
                    return { isValid: true, message: null };
                }

                const validationMessage = formValidateData.formDataValidation.rules[field.element.name](fieldValue, options, field);
                return {
                    isValid: validationMessage === true,
                    message: validationMessage === true ? null : validationMessage
                };
            },
            renderMessage(field, message, validate) {
                const fieldParentNode = this.getFieldParentNode(field);

                if (fieldParentNode) {
                    if (field.element.value && !validate) {
                        this.insertMessage(field, message);
                    } else {
                        this.removeExistingMessage(fieldParentNode);
                    }
                } else {
                    console.error(`Parent element not found for field with id '${field.element.id}'.`);
                }
            },
            removeExistingMessage(fieldParentNode) {
                const existingValidationMessage = fieldParentNode.querySelector('.vira-form-validation');
                if (existingValidationMessage) {
                    existingValidationMessage.remove();
                }
            },
            initializeLoginEmail() {
                this.loginEmail = this.getLoginEmail();
            },
            getLoginEmail() {
                return localStorage.getItem('loginEmail') || '';
            },
            ajaxSubmit(event) {
                const formId = event.target.id;
                const form = document.getElementById(formId);
                const formKey = getFormKeyCookie();
                const formData = this.prepareFormData(form, formKey);
                if(formId == 'login-form') {
                    this.loginEmail = document.getElementById('email').value;
                }

                this.addRequestIndicator();

                this.sendFormData(actionUrl, formData)
                    .then((response) => {
                        if (response.ok) {
                            this.handleFormSpecificActions(formId, form);
                            window.location.href = response.url;
                            if(formId == 'login-form') {
                                localStorage.setItem('loginEmail', this.loginEmail);
                            }
                            this.displayLoading = false;
                        } else {
                            console.error("Error:", response.status);
                        }
                        this.removeRequestIndicator();
                    })
                    .catch((error) => {
                        console.error("Fetch error:", error);
                        this.removeRequestIndicator();
                    });
            },

            prepareFormData(form, formKey) {
                const formData = new FormData(form);
                formData.append("form_key", formKey);
                return formData;
            },

            addRequestIndicator() {
                document.body.classList.add('vira-request');
            },

            removeRequestIndicator() {
                document.body.classList.remove('vira-request');
            },

            sendFormData(url, formData) {
                return fetch(url, {
                    method: "POST",
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    body: formData,
                    credentials: "include"
                });
            },

            handleFormSpecificActions(formId, form) {
                const formsWithCaptcha = ['login-form', 'accountcreate', 'contact-form'];
                if (formsWithCaptcha.includes(formId)) {
                    const captchaElement = document.querySelector('.required-captcha');
                    if (captchaElement) {
                        grecaptcha.reset();
                        captchaElement.checked = false;
                    }
                }
                if (formId === 'contact-form') {
                    form.reset();
                }
            },
            insertMessage(field, message) {
                const fieldParentNode = this.getFieldParentNode(field);

                if (!fieldParentNode) {
                    console.error(`Parent element not found for field with id '${field.element.id}'.`);
                    return;
                }

                const existingValidationMessage = this.getExistingValidationMessage(fieldParentNode);

                if (existingValidationMessage) {
                    this.updateValidationMessage(existingValidationMessage, message);
                } else {
                    this.createValidationMessage(fieldParentNode, field, message);
                }
            },

            getFieldParentNode(field) {
                return field.element.closest('.field-wrapper') || field.element.parentNode.parentNode;
            },

            getExistingValidationMessage(fieldParentNode) {
                return fieldParentNode.querySelector('.vira-form-validation .error-message');
            },

            updateValidationMessage(existingValidationMessage, message) {
                existingValidationMessage.innerText = message;
            },

            createValidationMessage(fieldParentNode, field, message) {
                const parentElement = document.createElement('div');
                parentElement.className = 'vira-form-validation';

                const messageElement = document.createElement('div');
                messageElement.innerText = message;
                messageElement.id = `${field.element.name}-error`;
                messageElement.className = 'error-message text-error mt-1 text-xs';

                parentElement.appendChild(messageElement);
                fieldParentNode.appendChild(parentElement);
            },
            insertRuleMessage(field, message, ruleValidated) {
                const fieldParentNode = this.getFieldParentNode(field);

                if (!fieldParentNode) {
                    console.error(`Parent element not found for field with id '${field.element.id}'.`);
                    return;
                }

                if (field.element.value && !ruleValidated) {
                    const existingRuleValidation = this.getExistingRuleValidationMessage(fieldParentNode);
                    if (existingRuleValidation) {
                        this.updateRuleValidationMessage(existingRuleValidation, message);
                    } else {
                        this.createRuleValidationMessage(fieldParentNode, field, message);
                    }
                } else {
                    this.removeExistingRuleValidationMessage(fieldParentNode);
                }
            },
            getExistingRuleValidationMessage(fieldParentNode) {
                return fieldParentNode.querySelector('.vira-form-validation-rule .warning-message');
            },

            updateRuleValidationMessage(existingRuleValidation, message) {
                existingRuleValidation.innerText = message;
            },

            createRuleValidationMessage(fieldParentNode, field, message) {
                const parentElement = document.createElement('div');
                parentElement.className = 'vira-form-validation-rule';

                const messageElement = document.createElement('div');
                messageElement.innerText = message;
                messageElement.id = `${field.element.name}-message`;
                messageElement.className = 'warning-message w-full p-4 bg-orange-100 my-2 font-medium text-gray-900';

                parentElement.appendChild(messageElement);
                fieldParentNode.appendChild(parentElement);
            },

            removeExistingRuleValidationMessage(fieldParentNode) {
                const existingRuleValidation = fieldParentNode.querySelector('.vira-form-validation-rule');
                if (existingRuleValidation) {
                    existingRuleValidation.remove();
                }
            },
            requiredMessageRender(field, message) {
                const fieldParentNode = this.getFieldParentNode(field);
                let allFieldsNotEmpty = true;
                const rules = field.rules;

                if (!rules.hasOwnProperty('required')) {
                    message = null;
                }

                if (fieldParentNode) {
                    if (this.isFieldRequired(rules)) {
                        if (this.isFieldEmpty(field)) {
                            allFieldsNotEmpty = false;
                            this.insertMessage(field, message);
                        } else {
                            this.removeExistingValidation(fieldParentNode);
                        }
                    }
                } else {
                    console.error(`Parent element not found for field with id '${field.element.id}'.`);
                }

                return allFieldsNotEmpty;
            },
            getFieldParentNode(field) {
                if (field.element) {
                    return field.element.closest('.field-wrapper') || (field.element.parentNode ? field.element.parentNode.parentNode : null);
                }
                return null;
            },

            isFieldRequired(rules) {
                return rules.hasOwnProperty('required') || this.hasAnyValue(rules);
            },

            isFieldEmpty(field) {
                return field.element.value.trim() === '';
            },

            removeExistingValidation(fieldParentNode) {
                const existingValidation = fieldParentNode.querySelector('.vira-form-validation');
                if (existingValidation) {
                    existingValidation.remove();
                }
            }
        }
    }
    formValidateData.formDataValidation = formDataValidation || {};
    formValidateData.formDataValidation.rules = validationRules || {};
    formValidateData.formDataValidation.addRule = (ruleName, pattern) => {
        validationRules[ruleName] = pattern;
    }
    formValidateData.formDataValidation.getRule = (ruleName) => {
        return validationRules[ruleName];
    }
})(window.formValidateData);